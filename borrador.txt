/////////////////////////////////////////////////calculador_frecuencias( textoOriginal , largoTexto ) ////

char ascii(int n) {
    char c = n;
    return c;
}

int numAscii (char c) {
    int n = c;
    return n;
}

Par *inicializar_arregloFrec() {
    Par *arregloFrec = malloc(sizeof(Par) * CARACTERES_TOTALES);
    for (int i = 0; i < CARACTERES_TOTALES; i++) {
        arregloFrec[i].frec = 0;
        arregloFrec[i].caracter = ascii(i);
    } 
    return arregloFrec;
}

Par *calculador_frecuencias(char *textoOriginal, int lenTexto) {
    Par *arregloFrec = inicializar_arregloFrec();
    for(int i = 0, pos; i < lenTexto; i++) {
        pos = numAscii(textoOriginal[i]);
        arregloFrec[pos].frec++;
    }
    return arregloFrec;
}

/////////////////////////////////////// crear_lista_ord (arreglofrec, largo) ////

Previamente creamos la estructura:

typedef struct _nodo {
  Par parfrec
  _nodo *next, *right, *left
} nodo

typedef nodo *listaHuff

 ///Luego defino la funcion:

listaHuff crear_lista_ord (arreglofrec, largo) {
  listaHuff lista = crearlista
  int contador = 0
  while (contador <= 255)
    lista = lista_insertar(lista, arreglofrec[contador],comp)
  return lista
}

Funcion Auxiliar:

SGList sglist_insert(SGList list, void *data, CopyFunction copy, CompareFunction compare) {
  GNode *newNode = malloc(sizeof(GNode));
  newNode->data = copy(data);
  newNode->next = NULL;
  if (sglist_empty(list)) return newNode;
  GNode *nodeTemp = list, *aux;
  if (compare(newNode->data, nodeTemp->data) <= 0) {
    newNode->next = nodeTemp;
    return newNode;
  }
  for(; nodeTemp->next != NULL; nodeTemp = nodeTemp->next){
    if (compare(newNode->data,nodeTemp->next->data) <= 0){
      aux = nodeTemp->next;
      nodeTemp->next = newNode;
      newNode->next = aux;
      return list;
    }
  }
  if (compare(nodeTemp->data, newNode->data) <= 0){
    nodeTemp->next = newNode;
    return list;
  }
}




////////////////////////////////////////////crear_arbol_huffman (listaOrdenada) ////////////


listaHuff crear_arbol_huffman (listaOrdenada) {
  while (lista->next != Null) {
    nodo nodo1 = inicio_lista(listaOrdenada);
    nodo nodo2 = nodo1->next
    int sumaFrecs = nodo1->parfrec->frec + nodo2->parfrec->frec  
    Par parnuevo  
    parnuevo->frec = sumaFrecs
    nodo nodoNuevo
    nodoNuevo = unirNodos(parNuevo, nodo1, nodo2)
    desapilar(listaOrdenada)
    desapilar(listaOrdenada)
    listaOrdenada = insertar(listaOrdenada, nodoNuevo)   
  }
  return listaOrdenada
}


//////////// codificar_datos(arbolDeHuffman) /////////////////////////////

///previamente creamos la estructura:

typedef struct {
  char caracter
  char *codif
} Codificacion

Codificacion codificar_datos(arbolDeHuffman) {
  Codificacion *listaCodific = malloc(sizeof(Codificacion)*255)
  char codigoInicial = "2"
  recorrerarbol_doble_extra(arbolDeHuffman, inorder, visitar,listaCodific, crear_lista()) 
}

recorrerarbol_doble_extra(arbolDeHuffman, inorder, visitar,listaCodific, listabits) {
  if (!btree_empty(arbol)){
      btree_recorrer(arbol->left, orden, visit, extra1, agregarfinallista(listabits, '0'));
      if (btree_empty(arbol->left && btree_empty(arbol->right))
        visit(arbol->dato, listaCodific, listabits);
      btree_recorrer(arbol->left, orden, visit, extra1, agregarfinallista(listabits, '1'));
  }
}

visit(dato, listaCodific, listabits) {
  int pos = ascii(dato);
  int len = largolista(listabits);
  listaCodific[pos]->codif = malloc(sizeof(char)*len)
  convertirastring(listabits, listaCodific[pos]->codif)
  listaCodific[pos]->caracter = dato
}





///////////////////////// serializar_arbol(arbolDeHuffman)////////////////////

char *serializar_arbol(...) {
  Lista lista = crearlista
  serializar_estructura(arbolDeHuffman)
  agregarcaracteres(arbolDeHuffman, lista)
  return convertirastring(lista)
}

void serializar_estructura(arbolDeHuffman, lista) {
  Nodo *temp = arbolDeHuffman
  if temp->left == null && temp->right == null
    lista = agregar_final(lista, 1)
  else {
    lista = agregar_final(lista, 0)
    serializar_arbol(temp->left, lista)
    serializar_arbol(temp->right, lista)
  }
}

void agregarcaracteres(arbolDeHuffman, lista) {
  recorrerarbol_extra(arbolDeHuffman, inorder, lista)
}

Nodo* agregar_final(Nodo* lista, int dato){
  Nodo* nuevoNodo = malloc(sizeof(Nodo));
  nuevoNodo->dato = dato;
  nuevoNodo->sig = NULL;
  if(lista == NULL){
    return nuevoNodo;
  }
  Nodo* p = lista;
  for(; p->sig != NULL; p = p->sig);
  p->sig = nuevoNodo;
  return lista;
}
///////////////////////////////////////// crear_texto_binario(arreglocod, textoOriginal)


char *crear_texto_binario(arreglocod , textoOriginal){
    Lista lista = crearlista;
    char *temp = arreglocod;
    int contador = 0, pos = 0;
    while(contador <= largoTXT){
         ********************************************
         *for (i = 0 ; i <= largoArray ; i++){      *
         *   if(textoOriginal[contador] == temp[i]);*
         *   agregar_final(temp[i]->codif , lista); *
         ******************* cambio******************
         pos = ascii(textoOriginal[contador])  //Numero ascii del caracter asociado
         agregrar_final(temp[pos]->codif, lista); 
            
        }
        contador++;
    }
    return convertirastring(lista)
}



