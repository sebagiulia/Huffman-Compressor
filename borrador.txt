/////////////////////////////////////////////////calculador_frecuencias( textoOriginal , largoTexto ) ////

///Previamente creamos la siguiente estructura:

typedef struct {
  int frec
  char caracter
} Par

///Luego creamos la funcion:

Par *calculador_frecuencias( textoOriginal, largoTexto ) { 
  Par *parfrec = malloc(sizeof(Par)*255);
  int contador = 0;
  while (contador <= 255) {
    parfrec[contador].caracter = ascii[contador];
    parfrec[contador]->frec = contar_frecuencia(parfrec[contador].caracter, textoOriginal, largoTexto);
    contador++;
  }
  return parfrec;
}

///Funcion auxilicar:

int contar_frecuencia(caracter, texto, largotexto) {
  int contador = 0, frec = 0;
  while (contador <= largotexto) {
    if (caracter == texto[contador]);
      frec++;
  }
  return frec;
}







/////////////////////////////////////// crear_lista_ord (arreglofrec, largo) ////

Previamente creamos la estructura:

typedef struct _nodo {
  Par parfrec
  _nodo *next, *right, *left
} nodo

typedef nodo *listaHuff

 ///Luego defino la funcion:

listaHuff crear_lista_ord (arreglofrec, largo) {
  listaHuff lista = malloc(...)
  int contador = 0
  while (contador <= 255)
    lista = lista_insertar(lista, partefrec[contador])
  return lista
}

Funcion Auxiliar:

lista_insertar ---> practica2 ejercicio 8




////////////////////////////////////////////crear_arbol_huffman (listaOrdenada) ////////////


listaHuff crear_arbol_huffman (listaOrdenada) {
  while (lista->next != Null) {
    nodo nodo1 = inicio_lista(listaOrdenada);
    nodo nodo2 = nodo1->next
    int sumaFrecs = nodo1->parfrec->frec + nodo2->parfrec->frec  
    Par parnuevo
    parnuevo->caracter = ' '   
    parnuevo->frec = sumaFrecs
    nodo nodoNuevo
    nodoNuevo = unirNodos(parNuevo, nodo1, nodo2)
    desapilar(listaOrdenada)
    desapilar(listaOrdenada)
    listaOrdenada = insertar(listaOrdenada, nodoNuevo)   
  }
  return listaOrdenada
}


//////////// codificar_datos(arbolDeHuffman) /////////////////////////////

///previamente creamos la estructura:

typedef struct {
  char caracter
  char *codif
} Codificacion

Codificacion codificar_datos(arbolDeHuffman) {
  Codificacion *listaCodific = malloc(sizeof(Codificacion)*255)
  char codigoInicial = "2"
  recorrerarbol_doble_extra(arbolDeHuffman, inorder, visitar,listaCodific, crear_lista()) 
}

recorrerarbol_doble_extra(arbolDeHuffman, inorder, visitar,listaCodific, listabits) {
  if (!btree_empty(arbol)){
      btree_recorrer(arbol->left, orden, visit, extra1, agregarfinallista(listabits, '0'));
      if (btree_empty(arbol->left && btree_empty(arbol->right))
        visit(arbol->dato, listaCodific, listabits);
      btree_recorrer(arbol->left, orden, visit, extra1, agregarfinallista(listabits, '1'));
  }
}

visit(dato, listaCodific, listabits) {
  int pos = ascii(dato);
  int len = largolista(listabits);
  listaCodific[pos]->codif = malloc(sizeof(char)*len)
  convertirastring(listabits, listaCodific[pos]->codif)
  listaCodific[pos]->caracter = dato
}





///////////////////////// serializar_arbol(arbolDeHuffman)////////////////////

char *serializar_arbol(...) {
  Lista lista = crearlista
  serializar_estructura(arbolDeHuffman)
  agregarcaracteres(arbolDeHuffman, lista)
  return convertirastring(lista)
}

void serializar_estructura(arbolDeHuffman, lista) {
  Nodo *temp = arbolDeHuffman
  if temp->left == null && temp->right == null
    lista = agregar_final(lista, 1)
  else {
    lista = agregar_final(lista, 0)
    serializar_arbol(temp->left, lista)
    serializar_arbol(temp->right, lista)
  }
}

void agregarcaracteres(arbolDeHuffman, lista) {
  recorrerarbol_extra(arbolDeHuffman, inorder, lista)
}

Nodo* agregar_final(Nodo* lista, int dato){
  Nodo* nuevoNodo = malloc(sizeof(Nodo));
  nuevoNodo->dato = dato;
  nuevoNodo->sig = NULL;
  if(lista == NULL){
    return nuevoNodo;
  }
  Nodo* p = lista;
  for(; p->sig != NULL; p = p->sig);
  p->sig = nuevoNodo;
  return lista;
}
///////////////////////////////////////// crear_texto_binario(arreglocod, textoOriginal)


char *crear_texto_binario(arreglocod , textoOriginal){
    Lista lista = crearlista;
    char *temp = arreglocod;
    int contador = 0, pos = 0;
    while(contador <= largoTXT){
         ********************************************
         *for (i = 0 ; i <= largoArray ; i++){      *
         *   if(textoOriginal[contador] == temp[i]);*
         *   agregar_final(temp[i]->codif , lista); *
         ******************* cambio******************
         pos = ascii(textoOriginal[contador])  //Numero ascii del caracter asociado
         agregrar_final(temp[pos]->codif, lista); 
            
        }
        contador++;
    }
    return convertirastring(lista)
}



